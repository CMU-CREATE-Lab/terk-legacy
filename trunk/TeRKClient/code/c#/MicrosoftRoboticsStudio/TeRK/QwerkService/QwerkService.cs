//------------------------------------------------------------------------------
// QwerkService.cs
//
//     This code was generated by the DssNewService tool.
//
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using peer;
using TeRK.services;
using TeRK.communications;
using TeRK.components;
using TeRK.components.services;
using W3C.Soap;
using xml = System.Xml;
using submgr = Microsoft.Dss.Services.SubscriptionManager;

namespace TeRK.client.qwerkservice
{
    [DisplayName("QwerkService")]
    [Description("The QwerkService Service")]
    [Contract(Contract.Identifier)]

    public class QwerkService : DsspServiceBase
    {
        private const int VERBOSITY = 0;
        private const int STATE_UPDATE_PERIOD_MS = 1000;

        private readonly int[] DEFAULT_MOTOR_ACCELERATIONS = new int[] { 16000, 16000, 16000, 16000 };
        private readonly int[] DEFAULT_MOTOR_POSITIONS = new int[] { 0, 0, 0, 0 };


        private Boolean trace
        {
            get { return VERBOSITY >= 1; }
        }
        private Boolean detailedTrace
        {
            get { return VERBOSITY >= 2; }
        }

        private QwerkServiceState _state = new QwerkServiceState();

        [ServicePort("/qwerkservice", AllowMultipleInstances = false)]
        private QwerkServiceOperations _mainPort = new QwerkServiceOperations();
        [Partner("SubMgr", Contract = submgr.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.CreateAlways)]
        private submgr.SubscriptionManagerPort _submgrPort = new submgr.SubscriptionManagerPort();

        private Port<DateTime> _qwerkStatePollingTimerPort = new Port<DateTime>();

        private QwerkController qwerkController;
        QwerkClientServantFactory servantFactory;
        DirectConnectCommunicator directCommunicator;
        RelayCommunicator relayCommunicator;
        bool cameraOn;



        public QwerkService(DsspServiceCreationPort creationPort)
            : base(creationPort)
        {
            servantFactory = new QwerkClientServantFactory();
            directCommunicator = new DirectConnectCommunicator("QwerkServiceClient", "QwerkServiceDirect.ice.properties", "Qwerk.Service.Client", servantFactory);
            relayCommunicator = new RelayCommunicator("QwerkServiceClient", "QwerkServiceRelay.ice.properties");
            cameraOn = false;
            if (trace) LogInfo("Communicators created.");
        }

        protected override void Start()
        {
            // Listen on the main port for requests and call the appropriate handler.
            ActivateDsspOperationHandlers();

            // Publish the service to the local Node Directory
            DirectoryInsert();

            // display HTTP service Uri
            LogInfo(LogGroups.Console, "Service uri: ");
            
            // start the polling timer which will fetch the qwerk state (uncomment this to activate polling for state)
            _qwerkStatePollingTimerPort.Post(DateTime.Now);
            Activate(Arbiter.Receive(true, _qwerkStatePollingTimerPort, QwerkStatePollerHandler));
        }

        protected override void Stop()
        {
            prepareForShutdown();
            base.Stop();
        }
      
        protected override void Shutdown()
        {
            prepareForShutdown();
            base.Shutdown();
        }

        private void prepareForShutdown()
        {
            if (this.qwerkController != null)
            {
                if (cameraOn)
                {
                    qwerkController.getVideoStreamService().stopCamera();
                    cameraOn = false;
                }
                qwerkController.getMotorService().stopMotors(new int[] { 0, 1, 2, 3 });
            }
            directCommunicator.shutdown();
            relayCommunicator.shutdown();
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            SubscribeRequestType request = subscribe.Body;
            LogInfo("Subscribe request from: " + request.Subscriber);

            yield return Arbiter.Choice(
                SubscribeHelper(_submgrPort, request, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    _state.Subscribers++;
                    base.SendNotification<Replace>(_submgrPort, request.Subscriber, _state);
                },
                delegate(Exception e)
                {
                    LogError(null, "Subscribe failed", e);
                }
            );
        }

        private void QwerkStatePollerHandler(DateTime signal)
        {
            _mainPort.Post(new UpdateQwerkState());
            Activate(Arbiter.Receive(false,
                                     TimeoutPort(STATE_UPDATE_PERIOD_MS),
                                     delegate(DateTime time)
                                     {
                                         _qwerkStatePollingTimerPort.Post(time);
                                     })
               );
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> RelayLoginHandler(RelayLogin login)
        {
            if(trace) LogInfo("RelayLogin Received");

            // login and register with the relay
            try
            {
                UserSessionPrx userSessionPrx = relayCommunicator.loginAndRegister(login.Body.TerkLogin, login.Body.TerkPassword);
                // connect to the qwerk
                try
                {
                    this.qwerkController = relayCommunicator.connectToQwerk(userSessionPrx, login.Body.QwerkLogin);
                }
                catch (PeerException e)
                {
                    string failure = "Failed to connect to Qwerk " + login.Body.QwerkLogin + ": " + e;
                    LogInfo(failure);
                    login.ResponsePort.Post(generateFault(failure));
                    yield break;
                }
            }
            catch (Exception e)
            {
                string failure = "Failed to register with the relay: " + e;
                LogInfo(failure);
                login.ResponsePort.Post(generateFault(failure));
                yield break;
            }
            login.ResponsePort.Post(DefaultUpdateResponseType.Instance);
            yield break;
        }
        
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> DirectLoginHandler(DirectLogin login)
        {
            if(trace) LogInfo("DirectLogin Received");
           
            try
            {
                TerkUserPrx terkUserPrx = directCommunicator.connectToPeer(login.Body.PeerIdentifier);
                if(trace) LogInfo("Connect complete!");
                QwerkPrx qwerkPrx = QwerkPrxHelper.uncheckedCast(terkUserPrx);
                this.qwerkController = new QwerkController(login.Body.PeerIdentifier, qwerkPrx, directCommunicator);
            }
            catch (Exception e)
            {
                string failure = "Failed to connect to Qwerk '" + login.Body.PeerIdentifier + "': " + e;
                LogInfo(failure);
                login.ResponsePort.Post(generateFault(failure));
                yield break;
            }
            
            login.ResponsePort.Post(DefaultUpdateResponseType.Instance);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> HttpGetHandler(HttpGet httpGet)
        {
            if(trace) LogInfo("HttpGet Received");
            httpGet.ResponsePort.Post(new HttpResponseType(_state));
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            if(trace) LogInfo("Get Received");
            get.ResponsePort.Post(_state);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetVideoFrameHandler(GetVideoFrame getVideoFrame)
        {
            if (trace) LogInfo("GetVideoFrame received");
            if (this.qwerkController != null)
            {
                if (!cameraOn)
                {
                    qwerkController.getVideoStreamService().startCamera();
                    cameraOn = true;
                }
                try
                {
                    VideoFrame frame = qwerkController.getVideoStreamService().getFrame();                    
                    if (frame.ImageData == null || frame.ImageData.Length == 0)
                        getVideoFrame.ResponsePort.Post(generateFault("Error while grabbing frame"));
                    else
                    {
                        VideoFrameMessage response = new VideoFrameMessage();
                        response.MyFrame = frame;

                        getVideoFrame.ResponsePort.Post(response);
                    }
                }
                catch (Exception x)
                {
                    getVideoFrame.ResponsePort.Post(generateFault(x.ToString()));
                    LogError(x);
                }
            }
            else
            {
                getVideoFrame.ResponsePort.Post(generateFault("Not Connected To Qwerk"));
            }
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public virtual IEnumerator<ITask> ReplaceHandler(Replace replace)
        {
            if(trace) LogInfo("Replace Received");
            QwerkState newState = replace.Body.QwerkState;
            
            if (!_state.QwerkState.Equals(newState))
            {
                _state.QwerkState = newState;
                _state.Ticks++;
                if (_state.Subscribers > 0)
                {
                    base.SendNotification<Replace>(_submgrPort, _state);
                }
            }
           
            replace.ResponsePort.Post(DefaultReplaceResponseType.Instance);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> UpdateQwerkStateHandler(UpdateQwerkState updateQwerkState)
        {
          //  LogInfo("UpdateQwerkState Received");

            if (this.qwerkController != null)
            {
                QwerkServiceState newState = new QwerkServiceState();
                newState._qwerkState = this.qwerkController.getQwerkState();
                Replace message = new Replace();
                message.Body = newState;
                _mainPort.Post(message);
            }                

         //   LogInfo("Update QwerkState returning...");
            updateQwerkState.ResponsePort.Post(DefaultUpdateResponseType.Instance);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> SetDigitalOutHandler(SetDigitalOut update)
        {
            if(trace) LogInfo("SetDigitalOut Received");
            if (this.qwerkController != null)
            {
                try
                {
                    TeRK.DigitalOutCommand dcommand = new DigitalOutCommand();

                    dcommand.digitalOutMask = new bool[8];
                    dcommand.digitalOutValues = new bool[8];

                    for (int i = 0; i < 8; i++)
                    {
                        dcommand.digitalOutMask[i] = (update.Body.DigitalOutArray[i] != null);
                        dcommand.digitalOutValues[i] = (update.Body.DigitalOutArray[i] == null) ? false : (bool)update.Body.DigitalOutArray[i];
                    }

                    if (detailedTrace)
                    {
                        LogInfo("Calling execute() on DigitalIOService with this DigitalOutCommand");
                        LogInfo("   Mask:          " + ArrayUtils.arrayToString(dcommand.digitalOutMask));
                        LogInfo("   Values:    " + ArrayUtils.arrayToString(dcommand.digitalOutValues));
                    }

                    this.qwerkController.getDigitalIOService().execute(dcommand);
                    update.ResponsePort.Post(DefaultUpdateResponseType.Instance);
                }
                catch (Exception x)
                {
                    update.ResponsePort.Post(generateFault(x.ToString()));
                }
            }
            else
            {
                update.ResponsePort.Post(generateFault("Not connected to Qwerk"));
            }
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SetServoPositionsHandler(SetServoPositions update)
        {
            if (trace) LogInfo("SetServoPositions Received");
            if (this.qwerkController != null)
            {
                try
                {
                    TeRK.ServoCommand servoCommand = new ServoCommand();

                    servoCommand.servoMask = new bool[16];
                    servoCommand.servoPositions = new int[16];
                    servoCommand.servoSpeeds = new int[16];
                    servoCommand.servoModes = new ServoMode[16];
                    for (int i = 0; i < 16; i++)
                    {
                        servoCommand.servoMask[i] = (update.Body.ServoPosArray[i] != null);
                        servoCommand.servoPositions[i] = (update.Body.ServoPosArray[i] == null) ? 0 : (int)update.Body.ServoPosArray[i];
                        servoCommand.servoSpeeds[i] = (update.Body.ServoVelArray[i] == null) ? 1000 : (int)update.Body.ServoVelArray[i];
                        servoCommand.servoModes[i] = (update.Body.ServoVelArray[i] == null) ? ServoMode.ServoMotorPositionControl : ServoMode.ServoMotorSpeedControl;
                    }

                    if(detailedTrace){
                        LogInfo("Calling execute() on ServoService with this ServoCommand");
                        LogInfo("   Mask:          " + ArrayUtils.arrayToString(servoCommand.servoMask));
                        LogInfo("   Modes:         " + arrayToString<ServoMode>(servoCommand.servoModes));
                        LogInfo("   Speeds:    " + ArrayUtils.arrayToString(servoCommand.servoSpeeds));
                        LogInfo("   Positions: " + ArrayUtils.arrayToString(servoCommand.servoPositions));
                    }

                    this.qwerkController.getServoService().execute(servoCommand);
                    update.ResponsePort.Post(DefaultUpdateResponseType.Instance);
                }
                catch (Exception x)
                {
                    update.ResponsePort.Post(generateFault(x.ToString()));
                }
            }
            else
            {
                update.ResponsePort.Post(generateFault("Not Connected To Qwerk"));
            }
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SetMotorSpeedHandler(SetMotorSpeed update)
        {
            if (trace) LogInfo("SetMotorSpeed Received");
            if (this.qwerkController != null)
            {
                try
                {
                    MotorCommand motorCommand = new MotorCommand();

                    motorCommand.motorMask = new bool[]
               {
                  update.Body.Motor0 != null,
                  update.Body.Motor1 != null,
                  update.Body.Motor2 != null,
                  update.Body.Motor3 != null
               };

                    motorCommand.motorVelocities = new int[]
               {
                  (update.Body.Motor0 == null) ? 0 : (int) update.Body.Motor0,
                  (update.Body.Motor1 == null) ? 0 : (int) update.Body.Motor1,
                  (update.Body.Motor2 == null) ? 0 : (int) update.Body.Motor2,
                  (update.Body.Motor3 == null) ? 0 : (int) update.Body.Motor3
               };

                    motorCommand.motorModes = new MotorMode[]
               {
                  MotorMode.MotorSpeedControl,
                  MotorMode.MotorSpeedControl,
                  MotorMode.MotorSpeedControl,
                  MotorMode.MotorSpeedControl
               };
                    motorCommand.motorAccelerations = DEFAULT_MOTOR_ACCELERATIONS;
                    motorCommand.motorPositions = DEFAULT_MOTOR_POSITIONS;

                    if (detailedTrace)
                    {
                        LogInfo("Calling execute() on MotorService with this MotorCommand");
                        LogInfo("   Mask:          " + ArrayUtils.arrayToString(motorCommand.motorMask));
                        LogInfo("   Modes:         " + arrayToString<MotorMode>(motorCommand.motorModes));
                        LogInfo("   Velocities:    " + ArrayUtils.arrayToString(motorCommand.motorVelocities));
                        LogInfo("   Accelerations: " + ArrayUtils.arrayToString(motorCommand.motorAccelerations));
                        LogInfo("   Positions:     " + ArrayUtils.arrayToString(motorCommand.motorPositions));
                    }
                    this.qwerkController.getMotorService().execute(motorCommand);
                    update.ResponsePort.Post(DefaultUpdateResponseType.Instance);

                }
                catch (Exception x)
                {
                    update.ResponsePort.Post(generateFault(x.ToString()));
                }
            }
            else
            {
                update.ResponsePort.Post(generateFault("Not Connected To Qwerk"));
            }
            yield break;
        }

        private static String arrayToString<T>(T[] array)
        {
            int length = array.Length;
            string[] strArray = new string[length];
            
            for(int i=0;i<length;i++)
                strArray[i] = array[i].ToString();
            
            return String.Join(" ", strArray);
        }

        public Fault generateFault(string reason)
        {
            Fault f = new Fault();
            ReasonText rt = new ReasonText();
            rt.Value = reason;
            ReasonText[] rts = new ReasonText[1];
            rts[0] = rt;
            f.Reason = rts;
            return f;
        }

    }
}